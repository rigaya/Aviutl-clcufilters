# clfilters

clfilters.auf は、OpenCL経由でGPUを使用し各種フィルタ処理を一括で行います。

フィルタ処理をGPU上で連続して行うことで、フィルタをそれぞれ実行するのと比べてCPU - GPU間のデータ転送を削減でき、高速化が期待できます。

## 想定動作環境

Windows 8.1/10/11 (x86/x64)  
Aviutl 1.00 以降  
Intel / NVIDIA / AMD のGPUドライバのインストールされた環境  

## clfilters 使用にあたっての注意事項

無保証です。自己責任で使用してください。clfiltersを使用したことによる、いかなる損害・トラブルについても責任を負いません。  

今後の更新でプロファイルの互換性がなくなるかもしれません。  
※非常にありえます。

## 使用可能なフィルタと適用順

フィルタについては下記の順番で適用されます。

- 色空間変換
- nnedi
- ノイズ除去(knn)
- ノイズ除去(pmd)
- ノイズ除去(smooth)
- リサイズ
- unsharp
- エッジレベル調整
- warpsharp
- バンディング低減
- 色調補正

## 使用方法

まず、使用するデバイスを選択してください。iGPU / dGPUどちらも利用可能です。

右側の [clinfo] ボタンでOpenCLの認識するGPUデバイスの詳細情報をテキストファイルに出力できます。

![デバイス選択](./data/clfilters_select_device.png)

その後、適用するフィルタにチェックを入れ、パラメータ調整を行ってください。

![パラメータ調整](./data/clfilters_params.png)

## 処理概要

Aviutlの内部フォーマット(YC48)からGPUで扱いやすいYUV444 16bitに変換したのち、GPUに転送してフィルタ処理を行います。その後、処理結果をCPUに転送し、YC48に戻して処理を完了させます。

YC48 → YUV444 16bit → GPUに転送 → VppフィルタをGPUで連続処理 → CPUに転送 → YUV444 16bit → YC48

## GPUフィルタの高速化

### GPUフィルタの課題

GPUでの演算処理は高速ですが、だからといってGPUフィルタが高速とは限りません。

- CPU-GPU間転送が遅い  
  Aviutlでは基本的にはフレームのデータがCPUにあるため、GPUフィルタを適用する場合、CPU-GPU間の通信が必要になります。ところがこれはかなり遅い処理で、転送開始のレイテンシも大きいし、転送にも時間がかかります。

- そもそもGPUでの計算開始が遅い。  
  直ちに計算を行ってくれるCPUと異なり、GPUに計算を発行してから実際に開始されるまでにそれなりの遅延があります。

CPU-GPU間転送や、GPUの処理開始遅延の影響で、計算を直列に並べると、フィルタによっては普通にCPU版をAVX2とかで最適化したほうが高速ということになってしまいます。GPU版を高速にするためには、

- CPU-GPU間転送を減らす
- CPU-GPU間転送やGPU計算を並行して実行する

などの対策が必要になります。

### 実施済みの最適化

#### CPU-GPU間転送を減らす

複数のGPUフィルタを一度に適用することで、CPU-GPU間転送を削減しています。GPUフィルタをひとつひとつ適用するのに比べ、転送回数を減らすことができます。

#### 内蔵GPU使用時のCPU-GPU間転送の削減

Intel GPUなど、内蔵GPUを使用する場合、OpenCLのAPIを適切に使うことでCPU-GPU間転送をなくすようにしました (いわゆるZero Copy)。

#### CPU-GPU間転送とGPU計算を並行して実行

保存時にはフレームを先読みすることで、CPU-GPU間転送とGPU計算を並行して行うことで、CPU-GPU間転送や処理開始の遅延を抑制しています。(実装の単純化のため、保存時のみ行っており、編集時は行っていません。)

#### メモリ確保・再確保の削減

GPUのメモリ確保はCPU以上に遅いので、なるべく確保したメモリを使いまわすように工夫しました。

#### 不要な同期の削除

まだGPUが遊んでいる時間が多い状況だったので、VTuneなどを使って、OpenCL APIの呼ばれ方などをチェックしました。リソースの解放漏れにより、無駄な同期がかかってしまっていたのを解消して高速化しました。

## 課題

clfilters には下記の課題があります。

- NVIDIAのGPU等、[cl_khr_image2d_from_buffer](https://www.khronos.org/registry/OpenCL/sdk/3.0/docs/man/html/cl_khr_image2d_from_buffer.html) というKHR拡張がサポートされない環境で無駄にメモリコピーが多発する。  
  OpenCL 2.0でこの拡張は標準になったので、いろいろなフィルタを cl_khr_image2d_from_buffer ありきで実装してきたのですが、
  OpenCL 3.0で標準から外れてしまい、NVIDIA GPUでは対応していないようです(Intel/AMDは対応)。
  CUDAでもほぼ同じことできるのになんでサポートしないの…。悲しみ。

- 時間方向に参照するフィルタに未対応。  
  vpp-convolution3d など。実装がややこしいので見送り中です。

## コンパイル環境

VC++ 2022 Community



